// Question 1

/*
 size_t - гарантируется, что в него поместится размер в байтах наибольшего возможного объекта в рамках данного устройства (unsigned).
 Лучше unsigned int, unsigned long и т.п. тем, что он независим от устройства (главным образом, разрядности процессора), что обеспечивает лучшую переносимость.
 */

/* О неявном приведении типов (компилятор чаще всего кинет warning, мб с -Wall) */
// problem 1
template<class T>
class Array {
    public:
    Array (int size);
    //...
    int length () const;
};                                      // bad - negative sized arrays?

template<class T>
class Array {
    public:
    Array (unsigned int size);          // size is now unsigned
    // ...
    unsigned int length () const;       // return type is now unsigned
};

                                        // still some problem.
Array<int> a (-1);                      // cast to big value (2^32 - 1)

                                        // want to detect such errors.
                                        // easy way - rewrite initial prototype and add <if> statement

template<class T>
Array<T>::Array (int size) {            // quite safe
#ifdef DEBUG
    if (size < 0) {
        // throw an exception or take some other action;
    }
#endif
    // ...
}

// of course, length also needs to return int in case we do "int n = a.length ();"

// problem 2
struct MyInt {
    operator int () {
        return 100;
    }
    operator double () {
        return 100.5;
    }
};

int main() {
    MyInt x;
    std::cout << x << '\n';             // CE
}

// Question 2
/*
 break в switch
 break в циклах (разумеется, всех)
 continue - переход в самый конец тела цикла
 */
// problem
while (count < 10) {
    if (count == 5)
        continue;                       // after incrementing the counter
    ++count;
}

// Question 3
//
/* Разница между объявлением и определением
 * Определение подмножество объявления.
 * Различие на примерах
*/

// Синтаксис объявления и определения переменных
/* Определение - */ int x = 10;  // - любое объявление переменной - определение


// Функций
/* Объявление  - */  int x (char b);
/* Определение - */  int x (char b) {};

// Классов и структур
/* Объявление  -  */ class x;
/* Определение -  */ сlass x {...};

// Алиасов для типов (с помощью слова using)
/* Объявление  -  */ using x = std::vector<int>;


// Question 4

/* CE - compile error      - ошибка времени компиляции
 * RE - runtime error      - ошибка во время исполнения программы
 * UB - undefined behavior - не предписано, как программа должна себя
 * повести в той или иной ситуации. Разница на лицо.
 * Причём при CE и RE программа падает, при UB не обязательно
*/

// Пример CE
/* Вызов функции, неопределённой ранее */ foo (); // Аналогично, обращение к необъявленной переменной, etc...
// Пример RE
/* Деление на 0                        */
int x = 5,
    b = 0;

x /= b;
// Пример UB
/* Выход за границы массива            */
auto x = new int[10];
x[11] = 0;
/* Переполнение числа                  */ int x = 2 << 40; 

// Question 5
// Любимый вопрос ded32, думаю, трудностей не возникнет.
// Проблема двойного удаления - быть может, во второй раз delete освободил память, которая была выделена другому объекту.

// Question 6
{
    int x = 0;
    {
        int x = 1;
        std::cout << x; // 1, более локальный объект
    }
}
// Ссылка на временный объект может продлить время его жизни (вообще, стоит плотнее заняться этим вопросом)

// Question 7
// Каждый указатель может принимать одно из значений
// 1. Указывать на объект или функцию
void f(int a, int b);

int *x_ptr = &x; // На объект
void (*f_ptr)(int, int) = &f; // На функцию с сигнатурой void (int, int)

// 2. Указывать на область памяти сразу за объектомD
int *after_x_ptr = &x + 1;

// 3. Нулевой указатель
int *null = nullptr;

// 4. Невалидное значение
int *wtf = reinterpret_cast<int *>(1337);

// Указатели на объект можно инициализировать с помощью оператора взятия адреса:
int *x_ptr = &x; // Указатель на x;
int * const * x_ptr_ptr = &x_ptr; // Неконстантный указатель на констнатный указатель на int

int arr[2];
int (*arr_ptr)[2] = &arr; // Указатель на массив из двух элементов

struct S {int n;};
S s = {1};
int *sp = &s.n; // Указатель на int, являющийся полем S

// С помощью operator-> можно обращаться к полям объекта по указателю на него:
S *s_ptr = &s; // Указатель на объект типа S
s_ptr->n = 2; // Изменение поля 

// С помощью .* и ->* можно обращаться к полям объектов и вызывать фукнции объектов по их указателям в объекте:
struct func_struct // Структура с функциями
{
    void f();
    void g();
}; 

void (func_struct::*f_ptr)() = &func_struct::f; // Указатель на функцию f структуры

// Скажем, у нас есть объект и указатель на объект:
func_struct obj;
func_struct *obj_ptr = &obj;

// Можем вызвать f:
obj.*f_ptr();
obj_ptr->*f_ptr();

// В силу неявного преобразования массива к указателю, возможно присваение указателя на первый элемент массива
int arr[100]; // Массив из ста элементов
int *arr_ptr = arr; // Указатель на первый элемент arr

// В силу неявного преобразования указателя на производный класс к базовому, возможно:
class Base {};
class Derived : Base {};

Derived d;
Base *b_ptr = &d;

// Указатель на объект любого типа может быть преобразоват к указателю на void:
void *b_void_ptr = b_ptr;

// Можно создавать указатели на членов класса (см. пример с .* и ->*)

// Арифметика указателей : происходит сдвиг на размер объекта
b_ptr++;
b_ptr--;
b_ptr = b_ptr + 10;
b_ptr = b_ptr - 10;

// Указатели можно разыменовывать. При этом получается lvalue

int x = 1;
int *x_ptr = &x;

(*x_ptr) = 2;
int y = (*x_ptr) + 5;

// Еще указатели можно сравнивать. 

// Если я что-то упустил/где-то ошибся, feel free to исправлять это все


// Question 8
const int a = 0;
const int* a = new int[10]; // pointer to const ints
int* const a = new int[10]; // const pointer to ints

// Константное выражение не может содержать операцию присваивания, инкременты и декременты
// Операции сравнения, арифметика, sizeof, запятая допустимы в константных выражениях 

// Question 9
// Ссылка (Reference) -- алиас (другое имя) для существующей переменной.
// Отличия ссылок от указателей:
// 1. Не существует NULL ссылок. Они всегда указывают на переменную
// 2. После инициализации ссылки, нельзя изменить переменную, на которую она указывает
// 3. Ссылка должна быть проинициализирована в момент создания (при объявлении или в списке инициализации)
// 4. Ссылки не могут быть элементами массивов

// Инициализация ссылки
int a = 0; // Создадим переменную
int &b = a; // Теперь b - ссылка на a.
b = 5; // Значения a и b равны 5

// Константные ссылки
// Можно объявить константную ссылку. При этом она ведет себя как константная переменная. Можно объявить 
// константную ссылку на неконстантный объект.

int a = 0;
const int b = 1;

const int& a_ref = a; // Можно
int& b_ref = b; // Не можно 

// Передача аргументов по константным ссылкам позволяет избежать копирования и гарантировать, что функция
// не изменит передаваемый объек

// Висячие ссылки (Dangling Reference)
// Ссылка, указывающая на объект, который был уничтожен, называется висячий. Обращение к такой ссылке приводит
// к Undefined Behaviour:

int& f() {
    int a = 10; // Создаем int на стеке
    return a; // Возвращаем указатель на int
} // При выходе из области видимости a уничтожается

int x = f(); 
x += 5; // Undefined Behaviour

// В качестве решения можно, скажем, передавать ссылку на static переменную, которая не уничтожается:
int& f() {
    static int a = 10;
    return a;
}

int x = f();

// Или просто выбрать другой подход к проблеме, если static переменная не подходит

// Question 10 -- Operator Precedence.
// Среди перечисленных в вопросе операторов действует следующий приоритет:
// 1. Постфиксный инкеремент и декремент -- возвращают rvalue
// 2. Префиксный инкремент и декремент -- возвращают lvalue, унарые + и - -- rvalue, 
//    логическое отрицание -- rvalue, побитовое отрицание -- rvalue, 
// 3. Бинарные *, / , % -- rvalue
// 4. Бинарные +, - -- rvalue
// 5. Побитовое И -- rvalue
// 6. Побитовый XOR -- rvalue
// 7. Побитовое ИЛИ -- rvalue
// 8. Логическое И -- rvalue
// 9. Логическое ИЛИ -- rvalue
// 10. Тернарный оператор -- Возвращает то, что было возвращено (лул), Присваивание -- lvalue, левая часть выражения
// после присваивания, возвращает lvalue, compound assignmend (+=, *=, /= и т. д.) -- аналогично
// 11. ',' -- Выполняет первый операнд, выполняет второй, возвращает второй.

// 1, 3, 4, 5, 6, 7, 8, 9, 11 -- Выполняются слева направо при равентсве приоритетов
// 2, 10 -- Выполняются справа налево при равентсве приоритетов

// Question 11 -- Explicit type conversion using static_cast
// Синтаксис static_cast:
static_cast<new_type>(expression);

// Но как же оно работает?
// 1. Если существует последовательность неявных преобразований от expression к new_type, или перегруженная
// инициализация new_type объектом типа typeof(expression), то static_cast возвращает временную переменную,
// проинициализированную как new_type Temp(expression);. Преобразование может включать неявные преобразования,
// вызов конструктора new_type или перегруженный оператор преобразования, написанный пользователем. 

// 2. Если new_type это ссылка или указатель на Derived, а expression -- lvalue невиртуального Base или
// prvalue-указатель на него, то static_cast выполняет downcast. Если Base виртуальный, недоступен или
// двумысленнен (при множественном наследовании, не знаю как лучше перевести ambiguous), то такой downcast
// некорректен. static_cast не выполняет проверок в runtime, поэтому его стоит использовать только если есть
// гарантия, что преобразование корректно (или использовать dynamic_cast).

// 3. Если new_type -- rvalue-ссылка, static_cast преобразует значение любого lvalue-expression в xvalue-ссылку
// на тот же объект, как и исходное выражение (или его подобъект, в зависимости от new_type) 

// 4. если new_type == void, то static_cast отбрасывает значение expression после того, как вычислит его

// 5. Если существует стандартное преобразование от new_type к typeof(expression), не использующее 
// преобразований lvalue в rvalue, массивов в указатель, нулевых указателей, нулевых указателей на член класса,
// указателей на функцию, булевых преобразований, то static_cast может применить обратное преобразование

// 6. Если преобразование expression в new_type требует преобразований lvalue в rvalue, массива в указатель,
// функции в указатель, то такое преобразование может быть выполнено с помощью static_cast

// 7. Enum могут быть преобразованы в int и типы с плавающей запятой 

// 8. Целочисленный тип или enum могут быть преобразованы в любой complete enumeration type (?????)

// 9. Указатель на член Derived класса может быть преобразован в указатель на член его Base класса, если 
// тот доступен и однозначно определен.

// 10. prvalue указатель на void может быть преобразован в указатель на любой объект. Если исходный
// указатель выровнен неправильно, то результат преобразования неопределен. 
// Если исходный указатель не-void типа это a, и существует pointer-interconvertible объект b (определение смотреть ниже),
// то результат -- объект b. Иначе адрес, на который указывает объект, не меняется
// 
// Объекты a и b являются pointer-interconvertible, если:
// а) a и b -- один и тот же объект 
// б) Один объект -- union, а другой -- его non-static член
// в) Один из объектов -- объект standard-layout класса (т.е. не имеющий виртуальных функций и 
// виртуальных родителей, имеющий одинаковые модификаторы доступа для всех его нестатических членов, 
// имеющий не более одного родителя с нестатическими полями и не имеющий наследников с нестатическими полями
// ИЛИ не имеющий родителей с нестатическими полями, имеющий родителем standard-layout класс или не имеющий
// родителей, не имеюищий родителя, совпадающего с первым нестатическим полем класса), а другой -- первый
// нестатический объект-член этого класса или, если таковых не имеется, любой подобъект родителя первого объекта
// г) Существует такой объект c, что a и c pointer-interconvertible и c и b pointer interconvertible

// простите если сбивчиво перевел :c

// Question 12 -- перегрузка функций 
// Перегрузка функций -- создание двух функций с одинаковым именем, но различными параметрами. Недопустимы
// две версии функции, различающиеся только возвращаемым значением

int f(int x, int y);
float f(int x, int y); // Нельзя

// Объявление функции имеет вид:
// noptr-declarator (parameter list) [cv] [ref] [except] [attr] [-> trailing]

// [] -- необязательный параметр
// noptr-declarator -- любой допустимый declarator, но если он начинается с *, & или &&, нужно окружить его
// скобо4ками
// parameter list -- набор (быть может, пустой) входных параметров, разделенный запятами
// cv -- constant/volatile, допускается только в объявлении нестатических функций-членов класса
// ref-qualifier, допускается только в объявлении нестатических функций-членов класса
// except -- С C++11 здесь может быть noexcept спецификация, до C++17 здесь может быть exception-спецификация
// attr -- Быть может, аттрибуты
// -> trailing -- т. н. trailing return type, может быть полезен, если зависит от шаблонных параметров или
// просто не очень удобно писать в начале:
template<typename T, typename U>
auto sum(T t, U u) -> decltype(t + u);

auto fpif(int) -> int(*)(int);

// Overload resolution steps:
// 1. Поиск функций-кандидатов по имени 
// 2. Отобрать из функций только подходящие, т. е. имеющие неявные преобразования от переданных параметров
// к параметрам принимаемым фукнциями.
// 3. Выбрать лучшую функцию-кандидат. Функция f1 лучше фукнции f2, если цепочка преобразований для каждого
// аргумента f1 не хуже цепочки преобразований для каждого аргумента функции f2, и...
// 3.1. Для некоторых аргументов цепочка преобразований для f1, чем для f2, или...:
int f(int); //1
int f(char); //2

f(4); // Вариант 1 лучше 

// 3.2. При разрешении перегрузки определенного пользователем преобразования типов, цепочка преобазований результата f1 лучше
// цепочки преобразований типов f2, или..
struct A {
    operator int(); // 1
    operator double(); // 2
}

A a;

int i = a; // Вариант 1
double d = a; // Вариант 2
float f = a; // Нипанятна

// 3.3. f1 возвращает требуемый reference, а f2 -- нет
struct X {
    operator A&(); // 1
    operator A&&(); // 2
}
A a;

X& l = a; // 1
X&& r = a; // 2

// 3.4. f1 -- специализация шаблона, а f2 -- нет

void f(int); // 1
template<typename T> void f(T); // 2

f(5); // Вариант 1

// 3.5. f1 более специализированная, чем f2.

// Порядок функций в исходном коде важен! Сначала происходят проверки цепочек приведения типов, а только
// потом -- выбор шаблонной подставновки. Поэтому, если написать

struct A {
    A(A const& ); // 1

    template<class T>
    A(T&&); // 2
};

A a;

A b(a); // Вызовется вариант 2. т. к. цепочка преобразований короче, хотя версия 1 -- не шаблонная

// Если один подходящий кандидат не выбран, произвойдет ошибка компиляции:

void f(double);
void f(float);

f(932); // Ошибка!

// TODO
// проверьте это кто нибудь

// Question 13
// Понятие класса, полей и методов класса, модификаторы доступа public, private и protected, отличие класса от структуры. 
// Применение операторов точка и стрелочка. Применение двойного двоеточия. Применение ключевого слова this. 
// Константные и неконстантные методы.

// Класс/структура — пользовательский тип данных. 
// • Отличия:
// Первое: по умолчанию все поля/методы в классе приватные, в структуре — публичные. 
// Второе: по умолчанию наследование классов — приватное, структур — публичное.
// • Поля   — переменные, связанные с классом. Все данные класса хранятся в его полях (кроме таблицы виртуальных функций)
// • Методы — функции, определенные внутри класса.
// • Модификаторы доступа — public, protected, private (ключевые слова, служащие для сокрытия данных). 
// public    — поле/метод доступны снаружи класса.
// protected — поле/метод доступны только внутри класса и только наследникам.
// private   — поле/метод доступны только внутри класса.
// (Однако если объявить класс B другом класса A (написать friend class B; в теле A), то класс B получит доступ ко всем членам класса A независимо от уровня доступа к ним. Аналогичное правило действует для дружественных функций.)

class min_theory
{
private:
    /* data */
    int private_a;

    /* methods */
    int get_test();

protected:

    int protected_a;

public:
    int public_a;

    min_theory(/* args */);
    ~min_theory();
};

min_theory::min_theory(/* args */) {
    printf("Я родился\n");
}

min_theory::~min_theory() {
    printf("Поминки\n");
}

int min_theory::get_test() {
    printf("I'm private\n");
}

// в теле методов класса можно использовать ключевое слово this, являющееся указателем на объект, от которого 
// этот метод был вызван

// Обращение к полям/методам объекта происходит через оператор "."

min_theory A;
A.public_a = 5; // (пацанский хор)
A.~min_theory();

// если же мы имеем указатель на объект, то в тех же контекстах оператор "." эквивалентен опреатору "->"

// Если метод не совершает изменений, касающихся содержимого объекта, то его следует пометить ключевым
// словом const (и конечно же, чтобы была возможность работать с константыми объектами)

const int& get_elem() const {
    return elem;
}

// Question 23
// https://docs.google.com/spreadsheets/d/10OtSa0QdUp0HyKJIySKQAp_1U6CDkdY8G3jnKMlePgE/edit?usp=sharing
        

// Question 27
int main() {
    std::map<int, int> a;
    a[2] = 3;
    a[5] = 7;
    a[10] = 2;
            
    for (auto it = a.begin (); it != a.end (); ++it)
        std::cout << it->second << '\n';
            
    for (auto it : a)
        std::cout << it.first << '\n';
            
            
    std::vector<int> b;
    b.push_back (2);
    b.push_back (3);
    b.push_back (7);
            
    for (auto it = b.begin (); it < b.end (); ++it)
        std::cout << *it << '\n';
            
    for (auto it : b)
        std::cout << it << '\n';
            
    return 0;
}
        
    

// Question 29
// Мотивировка и грустные истории C++ 03
// Хотим сделать функцию, которая сможет принимать временные объекты

// возможные имплементации на примере std::vector
int func(const std::vector<int>& v); // Нельзя будет менять объекты
int func(      std::vector<int>& v); // Не скомпилируется, если передать временный объект
int func(      std::vector<int>  v); // Будет копирование

// Вывод: все три способа плохие
// Рассмотрим стандартную реализацию swap
template <typename T>
void swap(T& x, T& y) {
    T tmp = x;
    x = y;
    y = tmp;
}
// ПЛОХО! ПЛОХО! Очень много копирования

// Решаем проблему копирования с помощью std::move
template <class T>
void swap(T& x, T& y) {
    T tmp = std::move(x); // После действия move в x будет лежать мусор, он станет невалидным, но копирования не будет
    x = std::move(y);
    y = std::move(tmp);
}
// Есть информация, что move лежит в <utility>, но у меня и без инклюда работало
// std::move преобразует аргумент в rvalue

// move-constructor
class C {
    C(C &&x) {}; // Конструктор перемещения (&& - ссылка на временный объект типа C)

// move-assignment оператор
    C& operator= (C&& x) {};
};
// Расширяем "Правило трех" до "Правила пяти". Могут генерироваться по умолчанию как и остальные

// Для string кажется, что должно быть так
String {
    char* str = nullptr;
    int size = 0;

    String(String&& string) noexcept :
        str(string.str),
        size(string.size) {

        string.str = nullptr;
    }

    String& operator= (String&& string) noexcept {
        if (&string == this)
        return *this;

        delete[] str;
        str = string.str;
        size = string.size;
        string.str = nullptr;

        return *this;
    }
};


// Question 30
// Мотивировка
void func() {
    int* p = new int;
    g(); // Может бросить исключение, а значит p никто не очистит, будет утечка памяти. Беда
    delete p;
}

// Решение:  ̶н̶а̶п̶и̶ш̶е̶м̶ ̶к̶у̶ч̶у̶ ̶к̶о̶с̶т̶ы̶л̶е̶й̶  обернем все в объект, который будет разрушаться
// при выходе из текущей области видимости
#include <memory>

std::shared_ptr<int> x(new int);
*x = 10;
// delete не нужен, так как он делается в деструкторе, в остальном использовании такой же как обычный указатель
// Если сделать два умных указателя на один обычный, то будет двойное удаление,
// но при этом shared_ptr поддерживает копирование

auto x = std::make_shared<int>(10);
// Аналогично предыдущему, но не требует явного new. Лучше писать так

int xCount = x.use_count();
// Количество копий
