// Question 1

/*
 size_t - гарантируется, что в него поместится размер в байтах наибольшего возможного объекта в рамках данного устройства (unsigned).
 Лучше unsigned int, unsigned long и т.п. тем, что он независим от устройства (главным образом, разрядности процессора), что обеспечивает лучшую переносимость.
 */

/* О неявном приведении типов (компилятор чаще всего кинет warning, мб с -Wall) */
// problem 1
template<class T>
class Array {
    public:
    Array (int size);
    //...
    int length () const;
};                                      // bad - negative sized arrays?

template<class T>
class Array {
    public:
    Array (unsigned int size);          // size is now unsigned
    // ...
    unsigned int length () const;       // return type is now unsigned
};

                                        // still some problem.
Array<int> a (-1);                      // cast to big value (2^32 - 1)

                                        // want to detect such errors.
                                        // easy way - rewrite initial prototype and add <if> statement

template<class T>
Array<T>::Array (int size) {            // quite safe
#ifdef DEBUG
    if (size < 0) {
        // throw an exception or take some other action;
    }
#endif
    // ...
}

// of course, length also needs to return int in case we do "int n = a.length ();"

// problem 2
struct MyInt {
    operator int () {
        return 100;
    }
    operator double () {
        return 100.5;
    }
};

int main() {
    MyInt x;
    std::cout << x << '\n';             // CE
}

// Question 2
/*
 break в switch
 break в циклах (разумеется, всех)
 continue - переход в самый конец тела цикла
 */
// problem
while (count < 10) {
    if (count == 5)
        continue;                       // after incrementing the counter
    ++count;
}

// Question 3
//
/* Разница между объявлением и определением
 * Определение подмножество объявления.
 * Различие на примерах
*/

// Синтаксис объявления и определения переменных
/* Определение - */ int x = 10;  // - любое объявление переменной - определение


// Функций
/* Объявление  - */  int x (char b);
/* Определение - */  int x (char b) {};

// Классов и структур
/* Объявление  -  */ class x;
/* Определение -  */ сlass x {...};

// Алиасов для типов (с помощью слова using)
/* Объявление  -  */ using x = std::vector<int>;


// Question 4

/* CE - compile error      - ошибка времени компиляции
 * RE - runtime error      - ошибка во время исполнения программы
 * UB - undefined behavior - не предписано, как программа должна себя
 * повести в той или иной ситуации. Разница на лицо.
 * Причём при CE и RE программа падает, при UB не обязательно
*/

// Пример CE
/* Вызов функции, неопределённой ранее */ foo (); // Аналогично, обращение к необъявленной переменной, etc...
// Пример RE
/* Деление на 0                        */
int x = 5,
    b = 0;

x /= b;
// Пример UB
/* Выход за границы массива            */
auto x = new int[10];
x[11] = 0;
/* Переполнение числа                  */ int x = 2 << 40; 

// Question 5
// Любимый вопрос ded32, думаю, трудностей не возникнет.
// Проблема двойного удаления - быть может, во второй раз delete освободил память, которая была выделена другому объекту.

// Question 6
{
    int x = 0;
    {
        int x = 1;
        std::cout << x; // 1, более локальный объект
    }
}
// Ссылка на временный объект может продлить время его жизни (вообще, стоит плотнее заняться этим вопросом)

// Question 7
// Каждый указатель может принимать одно из значений
// 1. Указывать на объект или функцию
void f(int a, int b);

int *x_ptr = &x; // На объект
void (*f_ptr)(int, int) = &f; // На функцию с сигнатурой void (int, int)

// 2. Указывать на область памяти сразу за объектомD
int *after_x_ptr = &x + 1;

// 3. Нулевой указатель
int *null = nullptr;

// 4. Невалидное значение
int *wtf = reinterpret_cast<int *>(1337);

// Указатели на объект можно инициализировать с помощью оператора взятия адреса:
int *x_ptr = &x; // Указатель на x;
int * const * x_ptr_ptr = &x_ptr; // Неконстантный указатель на констнатный указатель на int

int arr[2];
int (*arr_ptr)[2] = &arr; // Указатель на массив из двух элементов

struct S {int n;};
S s = {1};
int *sp = &s.n; // Указатель на int, являющийся полем S

// С помощью operator-> можно обращаться к полям объекта по указателю на него:
S *s_ptr = &s; // Указатель на объект типа S
s_ptr->n = 2; // Изменение поля 

// С помощью .* и ->* можно обращаться к полям объектов и вызывать фукнции объектов по их указателям в объекте:
struct func_struct // Структура с функциями
{
    void f();
    void g();
}; 

void (func_struct::*f_ptr)() = &func_struct::f; // Указатель на функцию f структуры

// Скажем, у нас есть объект и указатель на объект:
func_struct obj;
func_struct *obj_ptr = &obj;

// Можем вызвать f:
obj.*f_ptr();
obj_ptr->*f_ptr();

// В силу неявного преобразования массива к указателю, возможно присваение указателя на первый элемент массива
int arr[100]; // Массив из ста элементов
int *arr_ptr = arr; // Указатель на первый элемент arr

// В силу неявного преобразования указателя на производный класс к базовому, возможно:
class Base {};
class Derived : Base {};

Derived d;
Base *b_ptr = &d;

// Указатель на объект любого типа может быть преобразоват к указателю на void:
void *b_void_ptr = b_ptr;

// Можно создавать указатели на членов класса (см. пример с .* и ->*)

// Арифметика указателей : происходит сдвиг на размер объекта
b_ptr++;
b_ptr--;
b_ptr = b_ptr + 10;
b_ptr = b_ptr - 10;

// Указатели можно разыменовывать. При этом получается lvalue

int x = 1;
int *x_ptr = &x;

(*x_ptr) = 2;
int y = (*x_ptr) + 5;

// Еще указатели можно сравнивать. 

// Если я что-то упустил/где-то ошибся, feel free to исправлять это все


// Question 8
const int a = 0;
const int* a = new int[10]; // pointer to const ints
int* const a = new int[10]; // const pointer to ints

// Константное выражение не может содержать операцию присваивания, инкременты и декременты
// Операции сравнения, арифметика, sizeof, запятая допустимы в константных выражениях 

// Question 9
// Ссылка (Reference) -- алиас (другое имя) для существующей переменной.
// Отличия ссылок от указателей:
// 1. Не существует NULL ссылок. Они всегда указывают на переменную
// 2. После инициализации ссылки, нельзя изменить переменную, на которую она указывает
// 3. Ссылка должна быть проинициализирована в момент создания (при объявлении или в списке инициализации)
// 4. Ссылки не могут быть элементами массивов

// Инициализация ссылки
int a = 0; // Создадим переменную
int &b = a; // Теперь b - ссылка на a.
b = 5; // Значения a и b равны 5

// Константные ссылки
// Можно объявить константную ссылку. При этом она ведет себя как константная переменная. Можно объявить 
// константную ссылку на неконстантный объект.

int a = 0;
const int b = 1;

const int& a_ref = a; // Можно
int& b_ref = b; // Не можно 

// Передача аргументов по константным ссылкам позволяет избежать копирования и гарантировать, что функция
// не изменит передаваемый объек

// Висячие ссылки (Dangling Reference)
// Ссылка, указывающая на объект, который был уничтожен, называется висячий. Обращение к такой ссылке приводит
// к Undefined Behaviour:

int& f() {
    int a = 10; // Создаем int на стеке
    return a; // Возвращаем указатель на int
} // При выходе из области видимости a уничтожается

int x = f(); 
x += 5; // Undefined Behaviour

// В качестве решения можно, скажем, передавать ссылку на static переменную, которая не уничтожается:
int& f() {
    static int a = 10;
    return a;
}

int x = f();

// Или просто выбрать другой подход к проблеме, если static переменная не подходит

// Question 10 -- Operator Precedence.
// Среди перечисленных в вопросе операторов действует следующий приоритет:
// 1. Постфиксный инкеремент и декремент -- возвращают rvalue
// 2. Префиксный инкремент и декремент -- возвращают lvalue, унарые + и - -- rvalue, 
//    логическое отрицание -- rvalue, побитовое отрицание -- rvalue, 
// 3. Бинарные *, / , % -- rvalue
// 4. Бинарные +, - -- rvalue
// 5. Побитовое И -- rvalue
// 6. Побитовый XOR -- rvalue
// 7. Побитовое ИЛИ -- rvalue
// 8. Логическое И -- rvalue
// 9. Логическое ИЛИ -- rvalue
// 10. Тернарный оператор -- Возвращает то, что было возвращено (лул), Присваивание -- lvalue, левая часть выражения
// после присваивания, возвращает lvalue, compound assignmend (+=, *=, /= и т. д.) -- аналогично
// 11. ',' -- Выполняет первый операнд, выполняет второй, возвращает второй.

// 1, 3, 4, 5, 6, 7, 8, 9, 11 -- Выполняются слева направо при равентсве приоритетов
// 2, 10 -- Выполняются справа налево при равентсве приоритетов

// Question 11 -- Explicit type conversion using static_cast
// Синтаксис static_cast:
static_cast<new_type>(expression);

// Но как же оно работает?
// 1. Если существует последовательность неявных преобразований от expression к new_type, или перегруженная
// инициализация new_type объектом типа typeof(expression), то static_cast возвращает временную переменную,
// проинициализированную как new_type Temp(expression);. Преобразование может включать неявные преобразования,
// вызов конструктора new_type или перегруженный оператор преобразования, написанный пользователем. 

// 2. Если new_type это ссылка или указатель на Derived, а expression -- lvalue невиртуального Base или
// prvalue-указатель на него, то static_cast выполняет downcast. Если Base виртуальный, недоступен или
// двумысленнен (при множественном наследовании, не знаю как лучше перевести ambiguous), то такой downcast
// некорректен. static_cast не выполняет проверок в runtime, поэтому его стоит использовать только если есть
// гарантия, что преобразование корректно (или использовать dynamic_cast).

// 3. Если new_type -- rvalue-ссылка, static_cast преобразует значение любого lvalue-expression в xvalue-ссылку
// на тот же объект, как и исходное выражение (или его подобъект, в зависимости от new_type) 

// 4. если new_type == void, то static_cast отбрасывает значение expression после того, как вычислит его

// 5. Если существует стандартное преобразование от new_type к typeof(expression), не использующее 
// преобразований lvalue в rvalue, массивов в указатель, нулевых указателей, нулевых указателей на член класса,
// указателей на функцию, булевых преобразований, то static_cast может применить обратное преобразование

// 6. Если преобразование expression в new_type требует преобразований lvalue в rvalue, массива в указатель,
// функции в указатель, то такое преобразование может быть выполнено с помощью static_cast

// 7. Enum могут быть преобразованы в int и типы с плавающей запятой 

// 8. Целочисленный тип или enum могут быть преобразованы в любой complete enumeration type (?????)

// 9. Указатель на член Derived класса может быть преобразован в указатель на член его Base класса, если 
// тот доступен и однозначно определен.

// 10. prvalue указатель на void может быть преобразован в указатель на любой объект. Если исходный
// указатель выровнен неправильно, то результат преобразования неопределен. 
// Если исходный указатель не-void типа это a, и существует pointer-interconvertible объект b (определение смотреть ниже),
// то результат -- объект b. Иначе адрес, на который указывает объект, не меняется
// 
// Объекты a и b являются pointer-interconvertible, если:
// а) a и b -- один и тот же объект 
// б) Один объект -- union, а другой -- его non-static член
// в) Один из объектов -- объект standard-layout класса (т.е. не имеющий виртуальных функций и 
// виртуальных родителей, имеющий одинаковые модификаторы доступа для всех его нестатических членов, 
// имеющий не более одного родителя с нестатическими полями и не имеющий наследников с нестатическими полями
// ИЛИ не имеющий родителей с нестатическими полями, имеющий родителем standard-layout класс или не имеющий
// родителей, не имеюищий родителя, совпадающего с первым нестатическим полем класса), а другой -- первый
// нестатический объект-член этого класса или, если таковых не имеется, любой подобъект родителя первого объекта
// г) Существует такой объект c, что a и c pointer-interconvertible и c и b pointer interconvertible

// простите если сбивчиво перевел :cs



